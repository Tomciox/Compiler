#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include <map>
#include <vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;


/********************   Forward Declarations    ********************/

class Prog;
class FnDef;
class ListTopDef;
class Ar;
class ListArg;
class Blk;
class ListStmt;
class Empty;
class BStmt;
class Decl;
class NoInit;
class Init;
class ListItem;
class Ass;
class Incr;
class Decr;
class Ret;
class VRet;
class Cond;
class CondElse;
class While;
class SExp;
class Int;
class Str;
class Bool;
class Void;
class Fun;
class ListType;
class EVar;
class ELitInt;
class ELitTrue;
class ELitFalse;
class EApp;
class EString;
class Neg;
class Not;
class EMul;
class EAdd;
class ERel;
class EAnd;
class EOr;
class ListExpr;
class Plus;
class Minus;
class Times;
class Div;
class Mod;
class LTH;
class LE;
class GTH;
class GE;
class EQU;
class NE;
class Program;
class TopDef;
class Arg;
class Block;
class Stmt;
class Item;
class Type;
class Expr;
class AddOp;
class MulOp;
class RelOp;


/********************   Visitor Interfaces    ********************/

class Visitor
{
 public:
  virtual ~Visitor() {}
  virtual void visitProg(Prog *p) = 0;
  virtual void visitFnDef(FnDef *p) = 0;
  virtual void visitListTopDef(ListTopDef *p) = 0;
  virtual void visitAr(Ar *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitBlk(Blk *p) = 0;
  virtual void visitListStmt(ListStmt *p) = 0;
  virtual void visitEmpty(Empty *p) = 0;
  virtual void visitBStmt(BStmt *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitNoInit(NoInit *p) = 0;
  virtual void visitInit(Init *p) = 0;
  virtual void visitListItem(ListItem *p) = 0;
  virtual void visitAss(Ass *p) = 0;
  virtual void visitIncr(Incr *p) = 0;
  virtual void visitDecr(Decr *p) = 0;
  virtual void visitRet(Ret *p) = 0;
  virtual void visitVRet(VRet *p) = 0;
  virtual void visitCond(Cond *p) = 0;
  virtual void visitCondElse(CondElse *p) = 0;
  virtual void visitWhile(While *p) = 0;
  virtual void visitSExp(SExp *p) = 0;
  virtual void visitInt(Int *p) = 0;
  virtual void visitStr(Str *p) = 0;
  virtual void visitBool(Bool *p) = 0;
  virtual void visitVoid(Void *p) = 0;
  virtual void visitFun(Fun *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitELitInt(ELitInt *p) = 0;
  virtual void visitELitTrue(ELitTrue *p) = 0;
  virtual void visitELitFalse(ELitFalse *p) = 0;
  virtual void visitEApp(EApp *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitNeg(Neg *p) = 0;
  virtual void visitNot(Not *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitERel(ERel *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;
  virtual void visitPlus(Plus *p) = 0;
  virtual void visitMinus(Minus *p) = 0;
  virtual void visitTimes(Times *p) = 0;
  virtual void visitDiv(Div *p) = 0;
  virtual void visitMod(Mod *p) = 0;
  virtual void visitLTH(LTH *p) = 0;
  virtual void visitLE(LE *p) = 0;
  virtual void visitGTH(GTH *p) = 0;
  virtual void visitGE(GE *p) = 0;
  virtual void visitEQU(EQU *p) = 0;
  virtual void visitNE(NE *p) = 0;
  virtual void visitProgram(Program *p) = 0;
  virtual void visitTopDef(TopDef *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitStmt(Stmt *p) = 0;
  virtual void visitItem(Item *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitAddOp(AddOp *p) = 0;
  virtual void visitMulOp(MulOp *p) = 0;
  virtual void visitRelOp(RelOp *p) = 0;

  virtual void visitInteger(Integer i) = 0;
  virtual void visitDouble(Double d) = 0;
  virtual void visitChar(Char c) = 0;
  virtual void visitString(String s) = 0;
};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};

class AnalysisResult {
public:
  virtual Type *getType() const = 0;
  virtual bool isValue() const = 0;
  virtual bool isIntConst() const = 0;
  virtual bool isBoolConst() const = 0;
};

class AnalysisValue : public AnalysisResult {
public:
  Type *type;

  virtual Type *getType() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;

  AnalysisValue(Type *type_) : type(type_) {}
};

class AnalysisIntConst : public AnalysisResult {
public:
  int value;

  virtual Type *getType() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;

  AnalysisIntConst(int value_) : value(value_) {}
};

class AnalysisBoolConst : public AnalysisResult {
public:
  bool value;

  virtual Type *getType() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;

  AnalysisBoolConst(bool value_) : value(value_) {}
};

typedef std::map<std::string, Type*> FunScope;
typedef std::map<std::string, AnalysisResult*> Scope;

class semanticAnalysisMemory {
public:
  bool branch_return;
  std::string function_name;
  Type *ret, *assign;
	std::vector<Scope> scopes;
  FunScope fun_scope;
};

class Result {
public:
  virtual std::string toLLVM() const = 0;
  virtual std::string typeString() const = 0;
  virtual Type *getType() const = 0;
  virtual bool isPointer() const = 0;
  virtual bool isValue() const = 0;
  virtual bool isIntConst() const = 0;
  virtual bool isBoolConst() const = 0;
  virtual std::string toString() const = 0;
};

class Pointer : public Result {
public:
  Type *type;
  int address;

  Pointer(Type *type_, int address_) : 
    type(type_),
    address(address_) {}

  virtual std::string toLLVM() const;
  virtual std::string typeString() const;
  virtual Type *getType() const;
  virtual bool isPointer() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;
  virtual std::string toString() const;
};

class Value : public Result {
public:
  Type *type;
  int address;

  Value(Type *type_, int address_) : 
    type(type_),
    address(address_) {}

  virtual std::string toLLVM() const;
  virtual std::string typeString() const;
  virtual Type *getType() const;
  virtual bool isPointer() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;
  virtual std::string toString() const;
};

class IntConst : public Result {
public:
  int value;
  virtual std::string toLLVM() const;
  virtual std::string typeString() const;
  virtual Type *getType() const;
  virtual bool isPointer() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;
  virtual std::string toString() const;

  IntConst() : value(0) {}
  IntConst(int value_) : value(value_) {}
};

class BoolConst : public Result {
public:
  bool value;
  virtual std::string toLLVM() const;
  virtual std::string typeString() const;
  virtual Type *getType() const;
  virtual bool isPointer() const;
  virtual bool isValue() const;
  virtual bool isIntConst() const;
  virtual bool isBoolConst() const;
  virtual std::string toString() const;

  BoolConst() : value(false) {}
  BoolConst(bool value_) : value(value_) {}
};

typedef std::map<std::string, Pointer*> Context;

class generateMemory {
public:
  FILE *filename;
  FunScope functions;
  int fresh_label, fresh_block, next_string;
  Type *assign;
  std::vector<Context> context;
  std::map<std::string, int> string_constants;
  bool generate_return;
  int if_true, if_false;
  int last_generated_label;

  generateMemory(FILE *filename_) : 
    filename(filename_), if_true(0), if_false(0), last_generated_label(0) {}
};

/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable {
public:
  virtual Program *clone() const = 0;
  virtual void semanticAnalysis(semanticAnalysisMemory *m) = 0;
  virtual void generateLLVM(generateMemory *m) = 0;
};

class Prog : public Program
{
 public:
  ListTopDef *listtopdef_;

  Prog(const Prog &);
  Prog &operator=(const Prog &);
  Prog(ListTopDef *p1);
  ~Prog();
  virtual void accept(Visitor *v);
  virtual  Prog  *clone() const;
  void swap(Prog &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void generateLLVM(generateMemory *m);
};


class TopDef : public Visitable {
public:
  virtual TopDef *clone() const = 0;
  virtual void semanticAnalysisAddFunctions(semanticAnalysisMemory *m) = 0;
  virtual void semanticAnalysis(semanticAnalysisMemory *m) = 0;
  virtual void searchStringConstants(generateMemory *m) = 0;
  virtual void generateLLVMAddFunctions(generateMemory *m) = 0;
  virtual void generateLLVM(generateMemory *m) = 0;
};

class FnDef : public TopDef
{
 public:
  Type *type_;
  Ident ident_;
  ListArg *listarg_;
  Block *block_;

  FnDef(const FnDef &);
  FnDef &operator=(const FnDef &);
  FnDef(Type *p1, Ident p2, ListArg *p3, Block *p4);
  ~FnDef();
  virtual void accept(Visitor *v);
  virtual  FnDef  *clone() const;
  void swap(FnDef &);

  virtual void semanticAnalysisAddFunctions(semanticAnalysisMemory *m);
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVMAddFunctions(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};


class ListTopDef : public Visitable
{
 public:
  TopDef *topdef_;
  ListTopDef *listtopdef_;

  ListTopDef(const ListTopDef &);
  ListTopDef &operator=(const ListTopDef &);
  ListTopDef(TopDef *p1, ListTopDef *p2);
  ListTopDef(TopDef *p);
  ~ListTopDef();
  ListTopDef* reverse();
  ListTopDef* reverse(ListTopDef *l);
  virtual void accept(Visitor *v);
  virtual ListTopDef *clone() const;
  void swap(ListTopDef &);

  virtual void semanticAnalysisAddFunctions(semanticAnalysisMemory *m);
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVMAddFunctions(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};
class Arg : public Visitable {
public:
  virtual Arg *clone() const = 0;
  virtual Type *getType() const = 0;
  virtual char *getIdent() const = 0;
};

class Ar : public Arg
{
 public:
  Type *type_;
  Ident ident_;

  Ar(const Ar &);
  Ar &operator=(const Ar &);
  Ar(Type *p1, Ident p2);
  ~Ar();
  virtual void accept(Visitor *v);
  virtual Ar *clone() const;
  virtual Type *getType() const;
  virtual char *getIdent() const;
  void swap(Ar &);
};


class ListArg : public Visitable
{
 public:
  Arg *arg_;
  ListArg *listarg_;

  ListArg(const ListArg &);
  ListArg &operator=(const ListArg &);
  ListArg(Arg *p1, ListArg *p2);
  ListArg(Arg *p);
  ~ListArg();
  ListArg* reverse();
  ListArg* reverse(ListArg *l);
  virtual void accept(Visitor *v);
  virtual ListArg *clone() const;
  void swap(ListArg &);

  ListType* cast();
};
class Block : public Visitable {
public:
  virtual Block *clone() const = 0;
  virtual void semanticAnalysis(semanticAnalysisMemory *m) = 0;
  virtual void searchStringConstants(generateMemory *m) = 0;
  virtual void generateLLVM(generateMemory *m) = 0;
  virtual ListStmt *getListStmt() = 0;
};

class Blk : public Block
{
 public:
  ListStmt *liststmt_;

  Blk(const Blk &);
  Blk &operator=(const Blk &);
  Blk(ListStmt *p1);
  ~Blk();
  virtual void accept(Visitor *v);
  virtual  Blk  *clone() const;
  void swap(Blk &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
  virtual ListStmt *getListStmt();
};


class ListStmt : public Visitable
{
 public:
  Stmt *stmt_;
  ListStmt *liststmt_;

  ListStmt(const ListStmt &);
  ListStmt &operator=(const ListStmt &);
  ListStmt(Stmt *p1, ListStmt *p2);
  ListStmt(Stmt *p);
  ~ListStmt();
  ListStmt* reverse();
  ListStmt* reverse(ListStmt *l);
  virtual void accept(Visitor *v);
  virtual ListStmt *clone() const;
  void swap(ListStmt &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};
class Stmt : public Visitable {
public:
  virtual Stmt *clone() const = 0;
  virtual void semanticAnalysis(semanticAnalysisMemory *m) = 0;
  virtual void searchStringConstants(generateMemory *m) = 0;
  virtual void generateLLVM(generateMemory *m) = 0;
};

class Empty : public Stmt
{
 public:

  Empty(const Empty &);
  Empty &operator=(const Empty &);
  Empty();
  ~Empty();
  virtual void accept(Visitor *v);
  virtual  Empty  *clone() const;
  void swap(Empty &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m) {}
  virtual void searchStringConstants(generateMemory *m) {}
  virtual void generateLLVM(generateMemory *m) {}
};

class BStmt : public Stmt
{
 public:
  Block *block_;

  BStmt(const BStmt &);
  BStmt &operator=(const BStmt &);
  BStmt(Block *p1);
  ~BStmt();
  virtual void accept(Visitor *v);
  virtual  BStmt  *clone() const;
  void swap(BStmt &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class Decl : public Stmt
{
 public:
  Type *type_;
  ListItem *listitem_;

  Decl(const Decl &);
  Decl &operator=(const Decl &);
  Decl(Type *p1, ListItem *p2);
  ~Decl();
  virtual void accept(Visitor *v);
  virtual  Decl  *clone() const;
  void swap(Decl &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class Ass : public Stmt
{
 public:
  Ident ident_;
  Expr *expr_;

  Ass(const Ass &);
  Ass &operator=(const Ass &);
  Ass(Ident p1, Expr *p2);
  ~Ass();
  virtual void accept(Visitor *v);
  virtual  Ass  *clone() const;
  void swap(Ass &);

  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class Incr : public Stmt
{
 public:
  Ident ident_;

  Incr(const Incr &);
  Incr &operator=(const Incr &);
  Incr(Ident p1);
  ~Incr();
  virtual void accept(Visitor *v);
  virtual  Incr  *clone() const;
  void swap(Incr &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual void generateLLVM(generateMemory *m);
};

class Decr : public Stmt
{
 public:
  Ident ident_;

  Decr(const Decr &);
  Decr &operator=(const Decr &);
  Decr(Ident p1);
  ~Decr();
  virtual void accept(Visitor *v);
  virtual  Decr  *clone() const;
  void swap(Decr &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual void generateLLVM(generateMemory *m);
};

class Ret : public Stmt
{
 public:
  Expr *expr_;

  Ret(const Ret &);
  Ret &operator=(const Ret &);
  Ret(Expr *p1);
  ~Ret();
  virtual void accept(Visitor *v);
  virtual  Ret  *clone() const;
  void swap(Ret &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class VRet : public Stmt
{
 public:

  VRet(const VRet &);
  VRet &operator=(const VRet &);
  VRet();
  ~VRet();
  virtual void accept(Visitor *v);
  virtual  VRet  *clone() const;
  void swap(VRet &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual void generateLLVM(generateMemory *m);
};

class Cond : public Stmt
{
 public:
  Expr *expr_;
  Stmt *stmt_;

  Cond(const Cond &);
  Cond &operator=(const Cond &);
  Cond(Expr *p1, Stmt *p2);
  ~Cond();
  virtual void accept(Visitor *v);
  virtual  Cond  *clone() const;
  void swap(Cond &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class CondElse : public Stmt
{
 public:
  Expr *expr_;
  Stmt *stmt_1, *stmt_2;

  CondElse(const CondElse &);
  CondElse &operator=(const CondElse &);
  CondElse(Expr *p1, Stmt *p2, Stmt *p3);
  ~CondElse();
  virtual void accept(Visitor *v);
  virtual  CondElse  *clone() const;
  void swap(CondElse &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class While : public Stmt
{
 public:
  Expr *expr_;
  Stmt *stmt_;

  While(const While &);
  While &operator=(const While &);
  While(Expr *p1, Stmt *p2);
  ~While();
  virtual void accept(Visitor *v);
  virtual  While  *clone() const;
  void swap(While &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class SExp : public Stmt
{
 public:
  Expr *expr_;

  SExp(const SExp &);
  SExp &operator=(const SExp &);
  SExp(Expr *p1);
  ~SExp();
  virtual void accept(Visitor *v);
  virtual  SExp  *clone() const;
  void swap(SExp &);
  
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class Item : public Visitable {
public:
  virtual Item *clone() const = 0;
  virtual char *getIdent() = 0;
  virtual void semanticAnalysis(semanticAnalysisMemory *m) = 0;
  virtual void searchStringConstants(generateMemory *m) = 0;
  virtual void generateLLVM(generateMemory *m) = 0;
};

class NoInit : public Item
{
 public:
  Ident ident_;

  NoInit(const NoInit &);
  NoInit &operator=(const NoInit &);
  NoInit(Ident p1);
  ~NoInit();
  virtual void accept(Visitor *v);
  virtual  NoInit  *clone() const;
  void swap(NoInit &);
  virtual char *getIdent();
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};

class Init : public Item
{
 public:
  Ident ident_;
  Expr *expr_;

  Init(const Init &);
  Init &operator=(const Init &);
  Init(Ident p1, Expr *p2);
  ~Init();
  virtual void accept(Visitor *v);
  virtual  Init  *clone() const;
  virtual char *getIdent();
  void swap(Init &);
  virtual void semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual void generateLLVM(generateMemory *m);
};


class ListItem : public Visitable
{
 public:
  Item *item_;
  ListItem *listitem_;

  ListItem(const ListItem &);
  ListItem &operator=(const ListItem &);
  ListItem(Item *p1, ListItem *p2);
  ListItem(Item *p);
  ~ListItem();
  ListItem* reverse();
  ListItem* reverse(ListItem *l);
  virtual void accept(Visitor *v);
  virtual ListItem *clone() const;
  void swap(ListItem &);
};
class Type : public Visitable {
public:
  virtual Type *clone() const = 0;
  virtual const std::string toString() const = 0;
  virtual const std::string toLLVM() const = 0;
  virtual int hashcode() const = 0;
  virtual bool isInt() const = 0;
  virtual bool isStr() const = 0;
  virtual bool isBool() const = 0;
  virtual bool isVoid() const = 0;
  virtual bool isFunction() const = 0;

  bool operator==(const Type &other) {
    return this->hashcode() == other.hashcode();
  }

  bool operator!=(const Type &other) {
    return this->hashcode() != other.hashcode();
  }
};

class Int : public Type
{
 public:

  Int(const Int &);
  Int &operator=(const Int &);
  Int();
  ~Int();
  virtual void accept(Visitor *v);
  virtual  Int  *clone() const;
  void swap(Int &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int hashcode() const;
  virtual bool isInt() const;
  virtual bool isStr() const;
  virtual bool isBool() const;
  virtual bool isVoid() const;
  virtual bool isFunction() const;
};

class Str : public Type
{
 public:

  Str(const Str &);
  Str &operator=(const Str &);
  Str();
  ~Str();
  virtual void accept(Visitor *v);
  virtual  Str  *clone() const;
  void swap(Str &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int hashcode() const;
  virtual bool isInt() const;
  virtual bool isStr() const;
  virtual bool isBool() const;
  virtual bool isVoid() const;
  virtual bool isFunction() const;
};

class Bool : public Type
{
 public:

  Bool(const Bool &);
  Bool &operator=(const Bool &);
  Bool();
  ~Bool();
  virtual void accept(Visitor *v);
  virtual  Bool  *clone() const;
  void swap(Bool &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int hashcode() const;
  virtual bool isInt() const;
  virtual bool isStr() const;
  virtual bool isBool() const;
  virtual bool isVoid() const;
  virtual bool isFunction() const;
};

class Void : public Type
{
 public:

  Void(const Void &);
  Void &operator=(const Void &);
  Void();
  ~Void();
  virtual void accept(Visitor *v);
  virtual  Void  *clone() const;
  void swap(Void &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int hashcode() const;
  virtual bool isInt() const;
  virtual bool isStr() const;
  virtual bool isBool() const;
  virtual bool isVoid() const;
  virtual bool isFunction() const;
};

class Fun : public Type
{
 public:
  Type *type_;
  ListType *listtype_;

  Fun(const Fun &);
  Fun &operator=(const Fun &);
  Fun(Type *p1, ListType *p2);
  ~Fun();
  virtual void accept(Visitor *v);
  virtual  Fun  *clone() const;
  void swap(Fun &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int hashcode() const;
  virtual bool isInt() const;
  virtual bool isStr() const;
  virtual bool isBool() const;
  virtual bool isVoid() const;
  virtual bool isFunction() const;
};


class ListType : public Visitable
{
 public:
  Type *type_;
  ListType *listtype_;

  ListType(const ListType &);
  ListType &operator=(const ListType &);
  ListType(Type *p1, ListType *p2);
  ListType(Type *p);
  ~ListType();
  ListType* reverse();
  ListType* reverse(ListType *l);
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
  void swap(ListType &);
};
class Expr : public Visitable {
public:
  virtual Expr *clone() const = 0;
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m) = 0;
  virtual void searchStringConstants(generateMemory *m) = 0;
  virtual Result *generateLLVM(generateMemory *m) = 0;
};

class EVar : public Expr
{
 public:
  Ident ident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(Ident p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual  EVar  *clone() const;
  void swap(EVar &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class ELitInt : public Expr
{
 public:
  Integer integer_;

  ELitInt(const ELitInt &);
  ELitInt &operator=(const ELitInt &);
  ELitInt(Integer p1);
  ~ELitInt();
  virtual void accept(Visitor *v);
  virtual  ELitInt  *clone() const;
  void swap(ELitInt &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class ELitTrue : public Expr
{
 public:

  ELitTrue(const ELitTrue &);
  ELitTrue &operator=(const ELitTrue &);
  ELitTrue();
  ~ELitTrue();
  virtual void accept(Visitor *v);
  virtual  ELitTrue  *clone() const;
  void swap(ELitTrue &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class ELitFalse : public Expr
{
 public:

  ELitFalse(const ELitFalse &);
  ELitFalse &operator=(const ELitFalse &);
  ELitFalse();
  ~ELitFalse();
  virtual void accept(Visitor *v);
  virtual  ELitFalse  *clone() const;
  void swap(ELitFalse &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class EApp : public Expr
{
 public:
  Ident ident_;
  ListExpr *listexpr_;

  EApp(const EApp &);
  EApp &operator=(const EApp &);
  EApp(Ident p1, ListExpr *p2);
  ~EApp();
  virtual void accept(Visitor *v);
  virtual  EApp  *clone() const;
  void swap(EApp &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual Result *generateLLVM(generateMemory *m);
};

class EString : public Expr
{
 public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual  EString  *clone() const;
  void swap(EString &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual Result *generateLLVM(generateMemory *m);
};

class Neg : public Expr
{
 public:
  Expr *expr_;

  Neg(const Neg &);
  Neg &operator=(const Neg &);
  Neg(Expr *p1);
  ~Neg();
  virtual void accept(Visitor *v);
  virtual  Neg  *clone() const;
  void swap(Neg &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class Not : public Expr
{
 public:
  Expr *expr_;

  Not(const Not &);
  Not &operator=(const Not &);
  Not(Expr *p1);
  ~Not();
  virtual void accept(Visitor *v);
  virtual  Not  *clone() const;
  void swap(Not &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class EMul : public Expr
{
 public:
  Expr *expr_1, *expr_2;
  MulOp *mulop_;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Expr *p1, MulOp *p2, Expr *p3);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual  EMul  *clone() const;
  void swap(EMul &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class EAdd : public Expr
{
 public:
  Expr *expr_1, *expr_2;
  AddOp *addop_;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Expr *p1, AddOp *p2, Expr *p3);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual  EAdd  *clone() const;
  void swap(EAdd &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual Result *generateLLVM(generateMemory *m);
};

class ERel : public Expr
{
 public:
  Expr *expr_1, *expr_2;
  RelOp *relop_;

  ERel(const ERel &);
  ERel &operator=(const ERel &);
  ERel(Expr *p1, RelOp *p2, Expr *p3);
  ~ERel();
  virtual void accept(Visitor *v);
  virtual  ERel  *clone() const;
  void swap(ERel &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m);
  virtual Result *generateLLVM(generateMemory *m);
};

class EAnd : public Expr
{
 public:
  Expr *expr_1, *expr_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Expr *p1, Expr *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual  EAnd  *clone() const;
  void swap(EAnd &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};

class EOr : public Expr
{
 public:
  Expr *expr_1, *expr_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Expr *p1, Expr *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual  EOr  *clone() const;
  void swap(EOr &);
  virtual AnalysisResult *semanticAnalysis(semanticAnalysisMemory *m);
  virtual void searchStringConstants(generateMemory *m) {}
  virtual Result *generateLLVM(generateMemory *m);
};


class ListExpr : public Visitable
{
 public:
  Expr *expr_;
  ListExpr *listexpr_;

  ListExpr(const ListExpr &);
  ListExpr &operator=(const ListExpr &);
  ListExpr(Expr *p1, ListExpr *p2);
  ListExpr(Expr *p);
  ~ListExpr();
  ListExpr* reverse();
  ListExpr* reverse(ListExpr *l);
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
  void swap(ListExpr &);
};
class AddOp : public Visitable {
public:
  virtual AddOp *clone() const = 0;
  virtual const std::string toString() const = 0;
  virtual const std::string toLLVM() const = 0;
  virtual int calculate(int r1, int r2) const = 0;
};

class Plus : public AddOp
{
 public:

  Plus(const Plus &);
  Plus &operator=(const Plus &);
  Plus();
  ~Plus();
  virtual void accept(Visitor *v);
  virtual  Plus  *clone() const;
  void swap(Plus &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int calculate(int r1, int r2) const;
};

class Minus : public AddOp
{
 public:

  Minus(const Minus &);
  Minus &operator=(const Minus &);
  Minus();
  ~Minus();
  virtual void accept(Visitor *v);
  virtual  Minus  *clone() const;
  void swap(Minus &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int calculate(int r1, int r2) const;
};


class MulOp : public Visitable {
public:
  virtual MulOp *clone() const = 0;
  virtual const std::string toString() const = 0;
  virtual const std::string toLLVM() const = 0;
  virtual int calculate(int r1, int r2) const = 0;
};

class Times : public MulOp
{
 public:

  Times(const Times &);
  Times &operator=(const Times &);
  Times();
  ~Times();
  virtual void accept(Visitor *v);
  virtual  Times  *clone() const;
  void swap(Times &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int calculate(int r1, int r2) const;
};

class Div : public MulOp
{
 public:

  Div(const Div &);
  Div &operator=(const Div &);
  Div();
  ~Div();
  virtual void accept(Visitor *v);
  virtual  Div  *clone() const;
  void swap(Div &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int calculate(int r1, int r2) const;
};

class Mod : public MulOp
{
 public:

  Mod(const Mod &);
  Mod &operator=(const Mod &);
  Mod();
  ~Mod();
  virtual void accept(Visitor *v);
  virtual  Mod  *clone() const;
  void swap(Mod &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual int calculate(int r1, int r2) const;
};


class RelOp : public Visitable {
public:
  virtual RelOp *clone() const = 0;
  virtual const std::string toString() const = 0;
  virtual const std::string toLLVM() const = 0;
  virtual bool calculate(int r1, int r2) const = 0;
  virtual bool isEquals() const = 0;
};

class LTH : public RelOp
{
 public:

  LTH(const LTH &);
  LTH &operator=(const LTH &);
  LTH();
  ~LTH();
  virtual void accept(Visitor *v);
  virtual  LTH  *clone() const;
  void swap(LTH &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual bool calculate(int r1, int r2) const;
  virtual bool isEquals() const;
};

class LE : public RelOp
{
 public:

  LE(const LE &);
  LE &operator=(const LE &);
  LE();
  ~LE();
  virtual void accept(Visitor *v);
  virtual  LE  *clone() const;
  void swap(LE &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual bool calculate(int r1, int r2) const;
  virtual bool isEquals() const;
};

class GTH : public RelOp
{
 public:

  GTH(const GTH &);
  GTH &operator=(const GTH &);
  GTH();
  ~GTH();
  virtual void accept(Visitor *v);
  virtual  GTH  *clone() const;
  void swap(GTH &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual bool calculate(int r1, int r2) const;
  virtual bool isEquals() const;
};

class GE : public RelOp
{
 public:

  GE(const GE &);
  GE &operator=(const GE &);
  GE();
  ~GE();
  virtual void accept(Visitor *v);
  virtual  GE  *clone() const;
  void swap(GE &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual bool calculate(int r1, int r2) const;
  virtual bool isEquals() const;
};

class EQU : public RelOp
{
 public:

  EQU(const EQU &);
  EQU &operator=(const EQU &);
  EQU();
  ~EQU();
  virtual void accept(Visitor *v);
  virtual  EQU  *clone() const;
  void swap(EQU &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual bool calculate(int r1, int r2) const;
  virtual bool isEquals() const;
};

class NE : public RelOp
{
 public:

  NE(const NE &);
  NE &operator=(const NE &);
  NE();
  ~NE();
  virtual void accept(Visitor *v);
  virtual  NE  *clone() const;
  void swap(NE &);
  virtual const std::string toString() const;
  virtual const std::string toLLVM() const;
  virtual bool calculate(int r1, int r2) const;
  virtual bool isEquals() const;
};

#endif